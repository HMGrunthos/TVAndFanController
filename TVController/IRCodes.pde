#include <avr/pgmspace.h>

#define RLETABLELEN
#define NCMDS 30
#define CMDLEN 100
#define CMDFREQ 37000

PROGMEM const struct RLCType {
  unsigned short int code[2];
} rlcTypes[RLETABLELEN] = {{0x80, 0x40}, {0x10, 0x10}, {0x10, 0x30}, {0x10, 0xACE}};

PROGMEM const byte irCmdsEnc[NCMDS][13] = {
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x55, 0x59, 0x55, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x99, 0x55, 0x99, 0x55, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0x55, 0xA5, 0x55, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0x55, 0xA9, 0x55, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x95, 0x56, 0x95, 0x56, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0x56, 0xA9, 0x56, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x55, 0x65, 0x55, 0x65, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x65, 0x59, 0x65, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x69, 0x59, 0x69, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0x69, 0x65, 0x69, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x6A, 0x59, 0x6A, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x99, 0x6A, 0x99, 0x6A, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0x6A, 0xA5, 0x6A, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0x6A, 0xA9, 0x6A, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x96, 0x59, 0x96, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0x96, 0x65, 0x96, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x69, 0x96, 0x69, 0x96, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0x96, 0xA5, 0x96, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0x96, 0xA9, 0x96, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0x99, 0x65, 0x99, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0xA5, 0xA9, 0xA5, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0xAA, 0x65, 0xAA, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x95, 0xAA, 0x95, 0xAA, 0xE},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x96, 0x5A, 0x96, 0xD},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x99, 0x5A, 0x99, 0xD},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x95, 0x99, 0x96, 0x99, 0xD},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0x9A, 0xA6, 0x9A, 0xD},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0xA5, 0x66, 0xA5, 0xD},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x99, 0xA5, 0x9A, 0xA5, 0xD},
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0xA5, 0xA6, 0xA5, 0xD}
};

static unsigned short int irCmdPad[CMDLEN];
static unsigned short int *irPadPtr;
static volatile byte irSendCmdIdx;

void setupIRTransmitter()
{
  // COM2A = 00: disconnect OC2A
  // COM2B = 00: disconnect OC2B; to send signal set to 10: OC2B non-inverted
  // WGM2 = 101: phase-correct PWM with OCRA as top
  // CS2 = 000: no prescaling
  TCCR2A = _BV(WGM20);
  TCCR2B = _BV(WGM22) | _BV(CS20);
  OCR2A = 216; // The top value for the timer.  The modulation frequency will be SYSCLOCK / 2 / OCR2A.
  OCR2B = OCR2A / 3; // 33% duty cycle 

  pinMode(3, OUTPUT);
  digitalWrite(3, LOW);
}
byte decodeAndSendIRCommand(byte commandNum)
{
  if(commandNum >= NCMDS) {
    return 0;
  }

  while(irSendCmdIdx != 0); // Wait for the last command to complete
  
  PROGMEM const byte *inCmd = irCmdsEnc[commandNum];
  unsigned short int *outCmd = irCmdPad;
  byte currCmdByte = pgm_read_byte(inCmd);

  for(byte pairIdx = 0; pairIdx < CMDLEN/2; ) {
    unsigned short int cmdPair[2];
    byte rlcType;

    // Serial.print("Command :");
    // Serial.print(pairIdx, DEC);
    // Serial.print(": current byte :");
    // Serial.print(currCmdByte, BIN);
    
    rlcType = currCmdByte & 0x3;
    // Serial.print(": current code :");
    // Serial.print(rlcType, DEC);
    cmdPair[0] = pgm_read_word(rlcTypes[rlcType].code+0);
    // Serial.print(": words:0x");
    // Serial.print(cmdPair[0], HEX);
    // Serial.print(", 0x");
    cmdPair[1] = pgm_read_word(rlcTypes[rlcType].code+1);
    // Serial.print(cmdPair[1], HEX);
    // Serial.println(":");

    outCmd = translatePairTimes(cmdPair, outCmd);
    
    // Turn on the timer overflow interrupt if this is the first pair we've decoded
    if(pairIdx == 0) {
      irSendCmdIdx = CMDLEN;
      irPadPtr = irCmdPad;

      TCCR2A |= _BV(COM2B1); // Enable pin 3 PWM output
      TIMSK1 |= (1<<TOIE1); // Enable interrupt
    }

    currCmdByte = currCmdByte >> 2;
    pairIdx++;

    if(!(pairIdx%4)) {
      currCmdByte = pgm_read_byte(++inCmd);
    }
  }

  return 1;
}

unsigned short int *translatePairTimes(unsigned short int *inPair, unsigned short int *outPair)
{
  *outPair++ = (*inPair++*5)/8; // Convert from 27KHz cycles to 23125Hz cycles
  *outPair++ = (*inPair*5)/8; // Convert from 27KHz cycles to 23125Hz cycles

  return outPair;
}

ISR(TIMER1_OVF_vect)
{
  if(--(*irPadPtr) == 0) {
    if(--irSendCmdIdx == 0) { // Move to next command and disable this interrupt when done
      TIMSK1 &= ~(1<<TOIE1);
      return;
    }
    irPadPtr++; // Next interval
    TCCR2A ^= _BV(COM2B1); // Toggle pin 3 PWM output
  }
}
