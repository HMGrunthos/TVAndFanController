#include <avr/pgmspace.h>

#define RLETABLELEN
#define NCMDS 33
#define CMDLEN 100
#define CMDFREQ 37000

PROGMEM const struct RLCType {
  unsigned short int code[2];
} rlcTypes[RLETABLELEN] = {{0x80, 0x40}, {0x10, 0x10}, {0x10, 0x30}, {0x10, 0xACE}};

PROGMEM const byte irCmdsEnc[NCMDS][13] = {
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x55, 0x59, 0x55, 0xE}, // 1:Discrete Input - Slot 1:0
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0x55, 0x65, 0x55, 0xE}, // 2:Discrete Input - Slot 2:1
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x69, 0x55, 0x69, 0x55, 0xE}, // 3:Discrete Input - Slot 3:2
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x99, 0x55, 0x99, 0x55, 0xE}, // 5:Input:3
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0x55, 0xA5, 0x55, 0xE}, // 6:Picture Setup:4
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0x55, 0xA9, 0x55, 0xE}, // 7:Sound Setup:5
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x95, 0x56, 0x95, 0x56, 0xE}, // 12:Normalize:6
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0x56, 0xA9, 0x56, 0xE}, // 15:Off Timer:7
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x55, 0x65, 0x55, 0x65, 0xE}, // 32:Vol Up:8
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x65, 0x59, 0x65, 0xE}, // 33:Vol Down:9
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x69, 0x59, 0x69, 0xE}, // 49:Surround:10
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0x69, 0x65, 0x69, 0xE}, // 50:Mute:11
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x6A, 0x59, 0x6A, 0xE}, // 57:Display:12
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x99, 0x6A, 0x99, 0x6A, 0xE}, // 61:Power:13
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0x6A, 0xA5, 0x6A, 0xE}, // 62:Discrete Power On:14
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0x6A, 0xA9, 0x6A, 0xE}, // 63:Discrete Power Off:15
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x96, 0x59, 0x96, 0xE}, // 73:Enter:16
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0x96, 0x65, 0x96, 0xE}, // 74:Up Arrow:17
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x69, 0x96, 0x69, 0x96, 0xE}, // 75:Down Arrow:18
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0x96, 0xA5, 0x96, 0xE}, // 78:Left Arrow:19
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0x96, 0xA9, 0x96, 0xE}, // 79:Right Arrow:20
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0x99, 0x65, 0x99, 0xE}, // 82:Setup:21
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0x9A, 0xA5, 0x9A, 0xE}, // 94:Swap:22
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA9, 0xA5, 0xA9, 0xA5, 0xE}, // 103:Move / Zoom:23
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0xAA, 0x65, 0xAA, 0xE}, // 122:Discrete Input - PC:24 - Seems to give component input!
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x95, 0xAA, 0x95, 0xAA, 0xE}, // 124:Discrete Input - Component:25
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x96, 0x5A, 0x96, 0xD}, // 201:Discrete Aspect - Zoom:26
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x59, 0x99, 0x5A, 0x99, 0xD}, // 209:Discrete Aspect - Full:27
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x95, 0x99, 0x96, 0x99, 0xD}, // 212:Return:28
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x96, 0x55, 0xA5, 0x9A, 0x66, 0x9A, 0xD}, // 222:Aspect:29 (Sub device:4)
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0x65, 0xA5, 0x66, 0xA5, 0xD}, // 226:Select:30
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x96, 0x55, 0x99, 0xA5, 0x5A, 0xA5, 0xD}, // 229:Picture Pos/Size:31 (Sub device:4)
  {0x64, 0x55, 0x55, 0x65, 0x55, 0x55, 0x56, 0x55, 0xA5, 0xA5, 0xA6, 0xA5, 0xD}, // 230:Multi PIP:32
};

static unsigned short int irCmdPad[CMDLEN];
static unsigned short int *irPadPtr;
static volatile byte irSendCmdIdx;

void setupIRTransmitter()
{
  // COM2A = 00: disconnect OC2A
  // COM2B = 00: disconnect OC2B; to send signal set to 10: OC2B non-inverted
  // WGM2 = 101: phase-correct PWM with OCRA as top
  // CS2 = 000: no prescaling
  TCCR2A = _BV(WGM20);
  TCCR2B = _BV(WGM22) | _BV(CS20);
  OCR2A = 216; // The top value for the timer.  The modulation frequency will be SYSCLOCK / 2 / OCR2A.
  OCR2B = OCR2A / 3; // 33% duty cycle 

  pinMode(3, OUTPUT);
  digitalWrite(3, LOW);
}

boolean irTxDone()
{
  return irSendCmdIdx == 0;
}

byte decodeAndSendIRCommand(byte commandNum)
{
  if(commandNum >= NCMDS) {
    return 0;
  }

  while(!irTxDone()); // Wait for the last command to complete
  
  PROGMEM const byte *inCmd = irCmdsEnc[commandNum];
  unsigned short int *outCmd = irCmdPad;
  byte currCmdByte = pgm_read_byte(inCmd);

  for(byte pairIdx = 0; pairIdx < CMDLEN/2; ) {
    unsigned short int cmdPair[2];
    byte rlcType;

    // Serial.print("Command :");
    // Serial.print(pairIdx, DEC);
    // Serial.print(": current byte :");
    // Serial.print(currCmdByte, BIN);
    
    rlcType = currCmdByte & 0x3;
    // Serial.print(": current code :");
    // Serial.print(rlcType, DEC);
    cmdPair[0] = pgm_read_word(rlcTypes[rlcType].code+0);
    // Serial.print(": words:0x");
    // Serial.print(cmdPair[0], HEX);
    // Serial.print(", 0x");
    cmdPair[1] = pgm_read_word(rlcTypes[rlcType].code+1);
    // Serial.print(cmdPair[1], HEX);
    // Serial.println(":");

    outCmd = translatePairTimes(cmdPair, outCmd);
    
    // Turn on the timer overflow interrupt if this is the first pair we've decoded
    if(pairIdx == 0) {
      irSendCmdIdx = CMDLEN;
      irPadPtr = irCmdPad;

      TCCR2A |= _BV(COM2B1); // Enable pin 3 PWM output
      TIMSK1 |= (1<<TOIE1); // Enable interrupt
    }

    currCmdByte = currCmdByte >> 2;
    pairIdx++;

    if(!(pairIdx%4)) {
      currCmdByte = pgm_read_byte(++inCmd);
    }
  }

  return 1;
}

unsigned short int *translatePairTimes(unsigned short int *inPair, unsigned short int *outPair)
{
  *outPair++ = (*inPair++*5)/8; // Convert from 27KHz cycles to 23125Hz cycles
  *outPair++ = (*inPair*5)/8; // Convert from 27KHz cycles to 23125Hz cycles

  return outPair;
}

ISR(TIMER1_OVF_vect)
{
  if(--(*irPadPtr) == 0) {
    if(--irSendCmdIdx == 0) { // Move to next command and disable this interrupt when done
      TIMSK1 &= ~(1<<TOIE1);
      return;
    }
    irPadPtr++; // Next interval
    TCCR2A ^= _BV(COM2B1); // Toggle pin 3 PWM output
  }
}
